#!/bin/bash
# A set of Subroutines called by Macros for the SixDesk environment
sixdeskmess()
{
  local __sixdeskmesslevel
  if [ $# -eq 1 ] ; then
      __sixdeskmesslevel=$1
  else
      __sixdeskmesslevel=$sixdeskmesslevel
  fi
  if test "$__sixdeskmesslevel" -le "$sixdesklevel"
  then
    sixdeskday="`date +%a`"
    sixdeskdate="`date +%d/%m/%y`"
    sixdesktime="`date +%T`"
    sixdeskname="`basename $0`                "
    sixdeskname=`echo $sixdeskname | cut -b 1-15`
    if test "$sixdeskecho" != "" -o "$__sixdeskmesslevel" -eq 0
    then
      echo "$sixdeskday $sixdeskdate $sixdesktime ""$sixdeskname"" $sixdeskmess" 
    fi
    if test "$sixdesklogdir" != ""
    then
      echo "$sixdeskday $sixdeskdate $sixdesktime ""$sixdeskname"" $sixdeskmess" >> "$sixdesklogdir"/sixdesk.log
    else
      echo "$sixdeskday $sixdeskdate $sixdesktime ""$sixdeskname"" $sixdeskmess" >> sixdesk.log
    fi
  fi
}
sixdeskmktmp()
{
# Assumes that the directory (if specified) exists
  if test "$sixdesktmpdirarg" = ""
  then
    sixdesktmpdirarg="$PWD"
  else
    sixdeskfirst=`echo $sixdesktmpdirarg | cut -c1`
    if test "$sixdeskfirst" != "/"
    then
      sixdesktmpdirarg=$PWD/$sixdesktmpdirarg
    fi
  fi
  sixdesktmp=`mktemp -q $sixdesktmpdirarg/$sixdesktmpname.$sixdeskname.$sixdeskhostname.XXXXXX`
  chmod 644 $sixdesktmp
  if test $? -ne 0
  then

#MACRO mymess 0 sixdeskmktmp mktemp failed to produce a temporary file!!!
    sixdeskmesslevel=0
    sixdeskmess="sixdeskmktmp mktemp failed to produce a temporary file!!!"
    sixdeskmess
#MACRO mymess


#MACRO myexit 99
    sixdeskexitparam=99
    sixdeskexit
#MACRO myexit

  fi
  chmod 644 $sixdesktmp
}
sixdeskmktmpdir()
{
# Now does a mkdir -p in case the specified directory does not exist
  # e.g. /tmp/mcintosh
  if [ $# -ge 1 ] ; then
    sixdesktmpdirname=$1
  fi
  if [ $# -eq 2 ] ; then
    sixdesktmpdirarg=$2
  fi
  if test "$sixdesktmpdirarg" = ""
  then
    sixdesktmpdirarg="$PWD"
  else
    sixdeskfirst=`echo $sixdesktmpdirarg | cut -c1`
    if test "$sixdeskfirst" != "/"
    then
      sixdesktmpdirarg=$PWD/$sixdesktmpdirarg
    fi
    mkdir -p $sixdesktmpdirarg
    if test $? -ne 0
    then

#MACRO mymess 0 sixdeskmktmpdir: mkdir failed to make $sixdesktmpdirarg!!!
      sixdeskmesslevel=0
      sixdeskmess="sixdeskmktmpdir: mkdir failed to make $sixdesktmpdirarg!!!"
      sixdeskmess
#MACRO mymess


#MACRO myexit 99
      sixdeskexitparam=99
      sixdeskexit
#MACRO myexit

    fi
  fi
  sixdesktmpdir=`mktemp -q -d $sixdesktmpdirarg/$sixdesktmpdirname.$sixdeskname.$sixdeskhostname.XXXXXX`
  if test $? -ne 0
  then

#MACRO mymess 0 sixdeskmktmpdir: mktemp failed to produce a temporary directory!!!
    sixdeskmesslevel=0
    sixdeskmess="sixdeskmktmpdir: mktemp failed to produce a temporary directory!!!"
    sixdeskmess
#MACRO mymess


#MACRO myexit 99
    sixdeskexitparam=99
    sixdeskexit
#MACRO myexit

  fi
  chmod 755 $sixdesktmpdir
}
sixdeskexit()
{
  if [ $# -eq 1 ] ; then
      sixdeskexitparam=$1
  fi
  if test "$SIXDESKLOCKED" != ""
  then

#MACRO mymess 0 sixdeskexit: Freeing lock(s) $SIXDESKLOCKED!!!
    sixdeskmesslevel=0
    sixdeskmess="sixdeskexit: Freeing lock(s) $SIXDESKLOCKED!!!"
    sixdeskmess
#MACRO mymess

    while test "$SIXDESKLOCKED" != ""
    do
      sixdesklockeddir=`echo "$SIXDESKLOCKED" | cut -d " " -f1`

#MACRO myunlock $sixdesklockeddir
      sixdesklockdir=$sixdesklockeddir
      sixdeskunlock
#MACRO myunlock

    done
  fi
  exit "$sixdeskexitparam"
}
sixdeskunlock()
{
  if [ $# -eq 1 ] ; then
      sixdesklockdir=$1
  fi
  if test "$sixdesklockdir" = ""
  then
    sixdesklockdir="$PWD"
  else
    sixdeskfirst=`echo $sixdesklockdir | cut -c1`
    if test "$sixdeskfirst" != "/"
    then
      sixdesklockdir=$PWD/$sixdesklockdir
    fi
  fi
  if test -f "$sixdesklockdir/sixdesklock"
  then

#MACRO mymess 2 Freeing lock $sixdesklockdir
    sixdeskmesslevel=2
    sixdeskmess="Freeing lock $sixdesklockdir"
    sixdeskmess
#MACRO mymess


#MACRO mymess 2 held by `cat $sixdesklockdir/sixdesklock`
    sixdeskmesslevel=2
    sixdeskmess="held by `cat $sixdesklockdir/sixdesklock`"
    sixdeskmess
#MACRO mymess

    chmod 644 $sixdesklockdir/sixdesklock

#MACRO mymess 0 Lock $sixdesklockdir unlocked
    sixdeskmesslevel=0
    sixdeskmess="Lock $sixdesklockdir unlocked"
    sixdeskmess
#MACRO mymess

    SIXDESKLOCKED=`echo "$SIXDESKLOCKED" | sed -e's?'"$sixdesklockdir "'??'`
  else

#MACRO mymess 0 sixdeskunlock: The lock $sixdesklockdir does NOT exist!!!
    sixdeskmesslevel=0
    sixdeskmess="sixdeskunlock: The lock $sixdesklockdir does NOT exist!!!"
    sixdeskmess
#MACRO mymess

  fi
}
sixdesklock()
{
  if [ $# -eq 1 ] ; then
      sixdesklockdir=$1
  fi
  if test "$sixdesklockdir" = ""
  then
    sixdesklockdir="$PWD"
  else
    sixdeskfirst=`echo $sixdesklockdir | cut -c1`
    if test "$sixdeskfirst" != "/"
    then
      sixdesklockdir=$PWD/"$sixdesklockdir"
    fi
  fi
  if test ! -d "$sixdesklockdir"
  then

#MACRO mymess 0 sixdesklock: The requested lock directory $sixdesklockdir does not exist!!!
    sixdeskmesslevel=0
    sixdeskmess="sixdesklock: The requested lock directory $sixdesklockdir does not exist!!!"
    sixdeskmess
#MACRO mymess


#MACRO myexit 99
    sixdeskexitparam=99
    sixdeskexit
#MACRO myexit

  fi
  lockstat=0
  if test "$SIXDESKLOCKED" != ""
  then
    echo "$SIXDESKLOCKED" | grep "$sixdesklockdir " > /dev/null 2>&1
    if test $? -eq 0
    then

#MACRO mymess 0 sixdesklock: The lock $sixdesklockdir is already locked!!!
      sixdeskmesslevel=0
      sixdeskmess="sixdesklock: The lock $sixdesklockdir is already locked!!!"
      sixdeskmess
#MACRO mymess

      lockstat=1
    fi
  fi
  if test "$lockstat" -eq 0
  then

#MACRO mymess 2 sixdesklock: Obtaining lock $sixdesklockdir
    sixdeskmesslevel=2
    sixdeskmess="sixdesklock: Obtaining lock $sixdesklockdir"
    sixdeskmess
#MACRO mymess

    sixdeskgotit="false"
    sixdeskwait="false"
    lessmess=0
    while test "$sixdeskgotit" = "false"
    do
      if test ! -s $sixdesklockdir/sixdesklock
      then
        touch $sixdesklockdir/sixdesklock
        chmod 644 $sixdesklockdir/sixdesklock
      fi
      if test -w $sixdesklockdir/sixdesklock
      then
        sixdeskkey="$0 on `hostname` at `date` by proc $$"
        echo "$sixdeskkey" > $sixdesklockdir/sixdesklock
        if test $? -eq 0
        then
          sixdeskval=`cat $sixdesklockdir/sixdesklock`
          if test "$sixdeskval" = "$sixdeskkey"
          then
            chmod 444 $sixdesklockdir/sixdesklock
            sixdeskval=`cat $sixdesklockdir/sixdesklock`
            if test "$sixdeskval" = "$sixdeskkey"
            then
              sixdeskgotit="true"
              export SIXDESKLOCKED="$SIXDESKLOCKED""$sixdesklockdir "
            else
              chmod 644 $sixdesklockdir/sixdesklock
            fi
          fi
        fi
      fi
      if test "$sixdeskgotit" = "false"
      then
        if test "$lessmess" -eq 0
        then

#MACRO mymess 1 The directory $sixdesklockdir is currently locked by
          sixdeskmesslevel=1
          sixdeskmess="The directory $sixdesklockdir is currently locked by"
          sixdeskmess
#MACRO mymess


#MACRO mymess 1 script `cat $sixdesklockdir/sixdesklock`
          sixdeskmesslevel=1
          sixdeskmess="script `cat $sixdesklockdir/sixdesklock`"
          sixdeskmess
#MACRO mymess

        fi
        if test "$sixdeskwait" = "false"
        then
          if test "$lessmess" -eq 0
          then
            sixdeskwait="true"  

#MACRO mymess 1 This script $0 will just wait for it to become free.
            sixdeskmesslevel=1
            sixdeskmess="This script $0 will just wait for it to become free."
            sixdeskmess
#MACRO mymess


#MACRO mymess 1 If this situation continues for ever then it may be false.
            sixdeskmesslevel=1
            sixdeskmess="If this situation continues for ever then it may be false."
            sixdeskmess
#MACRO mymess


#MACRO mymess 1 You may have CTRL_C/killed a script and left the lock locked.
            sixdeskmesslevel=1
            sixdeskmess="You may have CTRL_C/killed a script and left the lock locked."
            sixdeskmess
#MACRO mymess


#MACRO mymess 1 Some other error like a missing file may also cause a script to die
            sixdeskmesslevel=1
            sixdeskmess="Some other error like a missing file may also cause a script to die"
            sixdeskmess
#MACRO mymess


#MACRO mymess 1 To reset the lock just issue an unlock $sixdesklockdir command
            sixdeskmesslevel=1
            sixdeskmess="To reset the lock just issue an unlock $sixdesklockdir command"
            sixdeskmess
#MACRO mymess

            lessmess=1
          fi
        fi
        delay=`date +%S`
        delay=`expr $delay + 5`

#MACRO mymess 2 Sleeping $delay seconds
        sixdeskmesslevel=2
        sixdeskmess="Sleeping $delay seconds"
        sixdeskmess
#MACRO mymess

        sleep $delay
      else

#MACRO mymess 0 Lock $sixdesklockdir locked
        sixdeskmesslevel=0
        sixdeskmess="Lock $sixdesklockdir locked"
        sixdeskmess
#MACRO mymess

      fi
    done
  fi
}
sixdeskchecklock()
{
    # $1: dir where to check
    dirToCheck=$1
    sixdeskmesslevel=1
    if [ ! -d ${dirToCheck} ] ; then
	sixdeskmess="The directory ${dirToCheck} does not exist!!!"
        sixdeskmess
    elif [ ! -f ${dirToCheck}/sixdesklock ] ; then
	sixdeskmess="The lockfile ${dirToCheck}/sixdesklock does not exist!!!"
        sixdeskmess
    elif [ ! -w ${dirToCheck}/sixdesklock ] ; then
	sixdeskmess="The directory ${dirToCheck} is currently locked by"
        sixdeskmess
        sixdeskmess="script `cat ${dirToCheck}/sixdesklock`"
        sixdeskmess
    else
	sixdeskmess="The directory ${dirToCheck} is currently unlocked"
        sixdeskmess
	sixdeskmess="last lock: `ls -l ${dirToCheck}/sixdesklock`"
        sixdeskmess
	sixdeskmess="`cat ${dirToCheck}/sixdesklock`"
        sixdeskmess
    fi
}
sixdesktunes()
{
  # Takes tunex, tuney, tunex1, tuney1, deltax, deltay
  # and produces
  # itunex, ituney, itunex1, ituney1, ideltax, ideltay
  if test "$tunex1" = "" -a "$tuney1" = ""
  then
    tunex1=$tunex
    tuney1=$tuney
    deltax=0.0
    deltay=0.0
  elif test "$tunex1" = ""
  then
    tunex1=$tunex
    deltax=0.0
  elif test "$tuney1" = ""
  then
    tuney1=$tuney
    deltay=0.0
  fi
  # Now we have the new code to do integer arithmetic on the tunescans
  itunexi=`echo "$tunex" | cut -d"." -f1`
  itunexi=$itunexi"0000"
  itunexi=`echo $itunexi | cut -c1-2`
  itunexf=`echo "$tunex" | cut -d"." -f2`
  itunexf=$itunexf"0000"
  itunexf=`echo $itunexf | cut -c1-4`
  itunex=$itunexi$itunexf

  ituneyi=`echo "$tuney" | cut -d"." -f1`
  ituneyi=$ituneyi"0000"
  ituneyi=`echo $ituneyi | cut -c1-2`
  ituneyf=`echo "$tuney" | cut -d"." -f2`
  ituneyf=$ituneyf"0000"
  ituneyf=`echo $ituneyf | cut -c1-4`
  ituney=$ituneyi$ituneyf

  itunex1i=`echo "$tunex1" | cut -d"." -f1`
  itunex1i=$itunex1i"0000"
  itunex1i=`echo $itunex1i | cut -c1-2`
  itunex1f=`echo "$tunex1" | cut -d"." -f2`
  itunex1f=$itunex1f"0000"
  itunex1f=`echo $itunex1f | cut -c1-4`
  itunex1=$itunex1i$itunex1f

  ituney1i=`echo "$tuney1" | cut -d"." -f1`
  ituney1i=$ituney1i"0000"
  ituney1i=`echo $ituney1i | cut -c1-2`
  ituney1f=`echo "$tuney1" | cut -d"." -f2`
  ituney1f=$ituney1f"0000"
  ituney1f=`echo $ituney1f | cut -c1-4`
  ituney1=$ituney1i$ituney1f

  ideltaxi=`echo "$deltax" | cut -d"." -f1`
  ideltaxi=$ideltaxi"0000"
  ideltaxi=`echo $ideltaxi | cut -c1-2`
  ideltaxf=`echo "$deltax" | cut -d"." -f2`
  ideltaxf=$ideltaxf"0000"
  ideltaxf=`echo $ideltaxf | cut -c1-4`
  ideltax=$ideltaxi$ideltaxf

  ideltayi=`echo "$deltay" | cut -d"." -f1`
  ideltayi=$ideltayi"0000"
  ideltayi=`echo $ideltayi | cut -c1-2`
  ideltayf=`echo "$deltay" | cut -d"." -f2`
  ideltayf=$ideltayf"0000"
  ideltayf=`echo $ideltayf | cut -c1-4`
  ideltay=$ideltayi$ideltayf

  if test "$itunex1" -lt "$itunex"
  then

#MACRO mymess 0 sixdesktunes: tunex1 $tunex1 .lt. tunex $tunex!!!
    sixdeskmesslevel=0
    sixdeskmess="sixdesktunes: tunex1 $tunex1 .lt. tunex $tunex!!!"
    sixdeskmess
#MACRO mymess


#MACRO myexit 12
    sixdeskexitparam=12
    sixdeskexit
#MACRO myexit

  elif test "$itunex1" -ne "$itunex" -a "$ideltax" -eq 0
  then

#MACRO mymess 0 sixdesktunes: deltax .eq. 0 !!!
    sixdeskmesslevel=0
    sixdeskmess="sixdesktunes: deltax .eq. 0 !!!"
    sixdeskmess
#MACRO mymess


#MACRO myexit 12
    sixdeskexitparam=12
    sixdeskexit
#MACRO myexit

  fi
  if test "$ituney1" -lt "$ituney"
  then

#MACRO mymess 0 sixdesktunes: tuney1 $tuney1 .lt. tuney $tuney!!!
    sixdeskmesslevel=0
    sixdeskmess="sixdesktunes: tuney1 $tuney1 .lt. tuney $tuney!!!"
    sixdeskmess
#MACRO mymess


#MACRO myexit 12
    sixdeskexitparam=12
    sixdeskexit
#MACRO myexit

  elif test "$ituney1" -ne "$ituney" -a "$ideltay" -eq 0
  then

#MACRO mymess 0 sixdesktunes: deltay .eq. 0 !!!
    sixdeskmesslevel=0
    sixdeskmess="sixdesktunes: deltay .eq. 0 !!!"
    sixdeskmess
#MACRO mymess


#MACRO myexit 12
    sixdeskexitparam=12
    sixdeskexit
#MACRO myexit

  fi

  # Finally get rid of any trailing zeros or one of two leading zeros
  tunex=`echo "$itunex" | cut -c1-2`"."`echo "$itunex" | cut -c3-6`
  tunex=`echo "$tunex" | sed -e's?0*$??'`
  tunex=`echo "$tunex" | sed -e's?^0??'`
  tuney=`echo "$ituney" | cut -c1-2`"."`echo "$ituney" | cut -c3-6`
  tuney=`echo "$tuney" | sed -e's?0*$??'`
  tuney=`echo "$tuney" | sed -e's?^0??'`
  tunex1=`echo "$itunex1" | cut -c1-2`"."`echo "$itunex1" | cut -c3-6`
  tunex1=`echo "$tunex1" | sed -e's?0*$??'`
  tunex1=`echo "$tunex1" | sed -e's?^0??'`
  tuney1=`echo "$ituney1" | cut -c1-2`"."`echo "$ituney1" | cut -c3-6`
  tuney1=`echo "$tuney1" | sed -e's?0*$??'`
  tuney1=`echo "$tuney1" | sed -e's?^0??'`
  # and report
  if test "$ideltax" -eq  0 -a "$ideltay" -eq 0
  then

#MACRO mymess 0 sixdesktunes: Tune ${tunex}_${tuney}
    sixdeskmesslevel=0
    sixdeskmess="sixdesktunes: Tune ${tunex}_${tuney}"
    sixdeskmess
#MACRO mymess

  else

#MACRO mymess 0 sixdesktunes: Tunescan (${tunex},${tuney}) to (${tunex1},${tuney1}) by (${deltax}, ${deltay})
    sixdeskmesslevel=0
    sixdeskmess="sixdesktunes: Tunescan (${tunex},${tuney}) to (${tunex1},${tuney1}) by (${deltax}, ${deltay})"
    sixdeskmess
#MACRO mymess

  fi
}
sixdeskinttunes()
{
  tmp=`echo $tunexx | sed -e's? ??g'`
  first=`echo $tunexx | cut -c1`
  if test "$first" = "."
  then
    inttunexx=0.
  else
    inttunexx=`echo $tmp | sed -e's?\([0-9][0-9]*\.\).*?\1?'`
  fi
  tmp=`echo $tuneyy | sed -e's/ //g'`
  first=`echo $tuneyy | cut -c1`
  if test "$first" = "."
  then
    inttuneyy=0.
  else
    inttuneyy=`echo $tmp | sed -e's?\([0-9][0-9]*\.\).*?\1?'`
  fi
}
sixdesklooptunes(){
    tunexx=`echo "$itunexx" | cut -c1-2`"."`echo "$itunexx" | cut -c3-6`
    tunexx=`echo "$tunexx" | sed -e's/0*$//'`
    tunexx=`echo "$tunexx" | sed -e's/^0//'`
    tuneyy=`echo "$ituneyy" | cut -c1-2`"."`echo "$ituneyy" | cut -c3-6`
    tuneyy=`echo "$tuneyy" | sed -e's/0*$//'`
    tuneyy=`echo "$tuneyy" | sed -e's/^0//'`
    sixdesktunes=$tunexx"_"$tuneyy
}
sixdeskamps()
{
  # Generate the integer amplitude equivalents, and update fampstart
  # ns1l
  junk=`echo $ns1l | grep '\.'`
  if test $? -ne 0
  then
    ampstart=$ns1l"000"
  else
    ins1l=`echo "$ns1l" | cut -d"." -f1`
    fns1l=`echo "$ns1l" | cut -d"." -f2`
    ins1l=$ins1l"000"
    fns1l=`echo $fns1l"000" | cut -c1-3`
    ampstart=`expr $ins1l + $fns1l`
  fi
  # ns2l
  junk=`echo $ns2l | grep '\.'`
  if test $? -ne 0
  then
    ampfinish=$ns2l"000"
  else
    ins2l=`echo "$ns2l" | cut -d"." -f1`
    fns2l=`echo "$ns2l" | cut -d"." -f2`
    ins2l=$ins2l"000"
    fns2l=`echo $fns2l"000" | cut -c1-3`
    ampfinish=`expr $ins2l + $fns2l`
  fi
  # nsincl
  junk=`echo $nsincl | grep '\.'`
  if test $? -ne 0
  then
    ampincl=$nsincl"000"
  else
    insincl=`echo "$nsincl" | cut -d"." -f1`
    fnsincl=`echo "$nsincl" | cut -d"." -f2`
    insincl=$insincl"000"
    fnsincl=`echo $fnsincl"000" | cut -c1-3`
    ampincl=`expr $insincl + $fnsincl`
  fi
  if test $ampstart -ge 99999 -o $ampfinish -ge 99999 -o $ampincl -ge 99999
  then

#MACRO mymess 0 sixdeskamps: Problem with amplitude definitions, $ns1l, $ns2l, $nsincl
    sixdeskmesslevel=0
    sixdeskmess="sixdeskamps: Problem with amplitude definitions, $ns1l, $ns2l, $nsincl"
    sixdeskmess
#MACRO mymess


#MACRO myexit 13
    sixdeskexitparam=13
    sixdeskexit
#MACRO myexit

  fi

#MACRO mymess 0 sixdeskamps: Amps $ampstart to $ampfinish by $ampincl
  sixdeskmesslevel=0
  sixdeskmess="sixdeskamps: Amps $ampstart to $ampfinish by $ampincl"
  sixdeskmess
#MACRO mymess

}
sixdeskrundir()
{
    if [ $# -eq 1 ] ; then
	local __lbackcomp=$1
    else
	local __lbackcomp=true
    fi
    if test "$BNL" = "" ; then
	if ${__lbackcomp} ; then
	    rundirname=`echo $runnamename | sed -e's?\([^%]*\)%\([^%]*\)%\([^%]\)%\([^%]*\)%\([^%]*\)%\([^%]*\)%?\1/\2/\3/\4/\5/e\6/?'`
	else
	    rundirname=`echo $runnamename | sed -e's?\([^%]*\)%\([^%]*\)%\([^%]\)%\([^%]*\)%\([^%]*\)%\([^%]*\)%?\1/\2/\3/\4/\5/\6/?'`
	fi
	rundirname=`echo $rundirname | sed -e's?/s/?/simul/?'`
	rundirname=`echo $rundirname | sed -e's?/t/?/trans/?'`
	rundirname=`echo $rundirname | sed -e's?/m/?/momen/?'`
	rundirname=`echo $rundirname | sed -e's?/d/?/da/?'`
    else
	rundirname=`echo $runnamename | sed -e 's?%?\/?g'`
    fi
    # remove trailing slashes
    rundirname=`echo ${rundirname} | sed 's:/*$::'`
}
sixdeskDefineUserTree(){
    # define the tree in the userspace
    
    # input variables are the starting points:
    # $1: root dir (ie $basedir in sixdeskenv)
    # $2: scratch dir (ie $scratchdir in sixdeskenv)
    # $3: workspace name (ie $workspace in sixdeskenv)

    # unset all that is exported by sixdeskenv that can be re-set
    unset  trackdir
    unset  sixtrack_input
    
    # basic paths (back-compatibility)
    export basedir=$1               # eg /afs/cern.ch/user/$initial/$LOGNAME
    export scratchdir=$2            # eg $basedir/scratch0
    export trackdir=$scratchdir/$3  # eg $scratchdir/w2
    export sixdeskhome=$basedir/$3/sixjobs # eg $trackdir/sixjobs
    export sixdeskhomeStudies=$sixdeskhome/studies

    # 
    export sixtrack_input=$scratchdir/sixtrack_input/$workspace/$LHCDescrip
    export sixdesklogs=$scratchdir/sixdesklogs/$workspace
    export sixdesklogdir=$sixdesklogs/$LHCDescrip
    export cronlogs=$scratchdir/cronlogs/$workspace
    export cronlogdir=$cronlogs/$LHCDescrip
    export sixdesktrack=$trackdir/track
    export sixdesktrackStudy=$sixdesktrack/$LHCDescrip
    export sixdeskwork=$scratchdir/work/$workspace/$LHCDescrip
    export sixdeskjobs=$sixdeskwork/$sixdeskplatform"jobs"
    export sixdeskjobs_logs=$sixdeskjobs/jobs_logs
    export sixdeskstudy=$sixdeskhomeStudies/$LHCDescrip
}
sixDeskDefineMADXTree(){
    local __SCRIPTDIR=$1
    # The following version of mad-X is used by the mad6t jobs.
    # All now call a madx executable so -X is no longer required.
#    export MADX_PATH="/afs/cern.ch/user/m/mad/bin"
    # Doesn't seem to work!
    #export MADX="madx_pro"
    # and the MUST? use for Massimo
    #export MADX="madx_dev"
    # and the new default
#    export MADX="madx"
    export maskFilesPath=$sixdeskhome/mask
    export controlFilesPath=$sixdeskhome/control_files
    export lsfFilesPath=$__SCRIPTDIR/templates/lsf
}
sixdeskDefinePointTree(){
    # $1: $LHCDesName
    # $2: MadX seed
    # $3: tag (see sixdeskrundir)
    # $4: $sixdesktunes
    # $5: $Ampl
    # $6: turn exponent
    # $7: angle
    # $8: $kk
    # $9: tree to $LHCDesName

    # returned variables
    Runnam=""
    Rundir=""
    RundirFullPath=""
    actualDirName=""
    actualDirNameFullPath=""

    # temporary variables
    iCountMax=1
    local __lerr=0

    # -- Runnam
    iCount=0
    local __lok=false
    while [ $iCount -lt $iCountMax ] ; do
	if [ $iCount -gt 1 ] ; then
	    sleep 1
	fi
	Runnam=$1'%'$2'%'$3'%'$4'%'$5'%'$6'%'$7
	sixdeskSanitizeString "${Runnam}" Runnam
	if [ -n "${Runnam}" ] ; then
	    __lok=true
	    break
	fi
	let iCount+=1
    done
    if ! ${__lok} ; then
	sixdeskInterceptProblem
	sixdeskmess="Failed to generate Runnam ${iCountMax} times! something wrong..."
	sixdeskmess
	let __lerr+=1
    fi

    # -- Rundir
    iCount=0
    local __lok=false
    while [ $iCount -lt $iCountMax ] ; do
	if [ $iCount -gt 1 ] ; then
	    sleep 1
	fi
	if [ -z "$6" ] ; then
	    runnamename=$1'%'$2'%'$3'%'$4'%'$5'%'$6'%'$7
	else
	    runnamename=$1'%'$2'%'$3'%'$4'%'$5'%e'$6'%'$7
	fi
	sixdeskrundir false
	Rundir=$rundirname
	sixdeskSanitizeString "${Rundir}" Rundir
	RundirFullPath="$9/$Rundir"
	sixdeskSanitizeString "${RundirFullPath}" RundirFullPath
	if [ -n "${Rundir}" ] && [ -n "${RundirFullPath}" ] ; then
	    __lok=true
	    break
	fi
	let iCount+=1
    done
    if ! ${__lok} ; then
	sixdeskInterceptProblem
	sixdeskmess="Failed to generate Rundir and RundirFullPath ${iCountMax} times! something wrong..."
	sixdeskmess
	let __lerr+=1
    fi

    # -- actualDirName
    iCount=0
    local __lok=false
    while [ $iCount -lt $iCountMax ] ; do
	let iCount+=1
	if [ $iCount -gt 1 ] ; then
	    sleep 1
	fi
	if [ -z "$6" ] ; then
	    runnamename=$1'%'$2'%'$3'%'$4'%'$5'%'$6'%.'$8
	else
	    runnamename=$1'%'$2'%'$3'%'$4'%'$5'%e'$6'%.'$8
	fi
	sixdeskrundir false
	actualDirName=$rundirname
	sixdeskSanitizeString "${actualDirName}" actualDirName
	actualDirNameFullPath="$9/$actualDirName"
	sixdeskSanitizeString "${actualDirNameFullPath}" actualDirNameFullPath
	if [ -n "${actualDirName}" ] && [ -n "${actualDirNameFullPath}" ] ; then
	    __lok=true
	    break
	fi
    done
    if ! ${__lok} ; then
	sixdeskInterceptProblem
	sixdeskmess="Failed to generate actualDirName and actualDirNameFullPath ${iCountMax} times! something wrong..."
	sixdeskmess
	let __lerr+=1
    fi
    return $__lerr
}
sixdeskDefineWorkUnitName(){
    # $1: workspace name (ie $workspace)
    # $2: name of job (ie $Runnam)
    # $3: task ID (ie $sixdesktaskid)
    sixdeskTaskName=`echo $1"_"$2 | sed -e's?%?__?g'`
    workunitName=$sixdeskTaskName"_1_sixvf_"$3
}
sixdeskDefineMegaZipName(){
    local __workSpaceName=$1
    local __studyName=$2
    local __megaZipName="${LOGNAME}_${__workSpaceName}_${__studyName}_`date "+%Y-%m-%d_%H-%M-%S"`.zip"
    eval  "$3=${__megaZipName}"
}
sixdeskGetTaskIDfromWorkUnitName(){
    sixdesktaskid=`echo "$1" | awk 'BEGIN{FS="_";}{print ($NF)}'`
}
sixdeskAngleStep(){
    local __totAngle=$1
    local __kmax=$2
    local __lbackcomp=$3
    if ${__lbackcomp} ; then
	AngleStep=`gawk -v "totAngle=${__totAngle}" -v "kmax=${__kmax}" 'END{print (totAngle/(kmax+1))}' /dev/null`
    else
	AngleStep=`gawk -v "totAngle=${__totAngle}" -v "kmax=${__kmax}" 'END{printf ("%.16E",totAngle/(kmax+1))}' /dev/null`
    fi
}
sixdeskAngle(){
    Angle=`gawk -v "angleStep=$1" -v "kk=$2" 'END{print (angleStep*kk)}' /dev/null`
}
sixdeskScaledKstep(){
    local __kstep=$1
    local __reduce_angs_with_aplitude=$2
    local __ampstart=$3
    local __ampfinish=$4
    local __factor=0.3
    scaled_kstep=${__kstep}
    if [ ${__reduce_angs_with_aplitude} -eq 1 ] ;then
        if [ "${__ampstart}" -gt ${__factor} ] ;then
            local __ang_scaling_factor=`gawk -v "ampfinish=${__ampfinish}" -v "ampstart=${__ampstart}" 'END{print (ampfinish/ampstart)}' /dev/null`
        else
            local __ang_scaling_factor=`gawk -v "ampfinish=${__ampfinish}" -v "factor=${__factor}" 'END{print(ampfinish/factor)}' /dev/null`
        fi
        scaled_kstep=`gawk -v "kstep=${__kstep}" -v "ang_scaling_factor=${__ang_scaling_factor}" 'END{print(kstep*ang_scaling_factor)}' /dev/null`
    fi
}
sixdeskkang(){
    local __kk=$1
    local __kmax=$2
    local __lbackcomp=$3
    if ${__lbackcomp} ; then
	kang=`gawk -v "kk=${__kk}" -v "kmax=${__kmax}" 'END{print (kk/(kmax+1))}' /dev/null`
    else
	kang=`gawk -v "kk=${__kk}" -v "kmax=${__kmax}" 'END{printf ("%.16E",kk/(kmax+1))}' /dev/null`
    fi
}
sixdeskRatio(){
    local __kang=$1
    local __lbackcomp=$2
    if ${__lbackcomp} ; then
	local __hpi=1.570796
    else
	local __hpi=1.5707963267948966
    fi
    ratio=`gawk -v "kang=${__kang}" -v "hpi=${__hpi}" 'END{tan=sin(hpi*kang)/cos(hpi*kang); if (tan<0) {tan=-tan}; if (tan<1.0E-15) {tan=0.0}; ratio=tan**2; print ratio}' /dev/null`
}
sixdeskax0(){
    local __ratio=$6
    local __square=$8
    local __lbackcomp=${11}
    if ${__lbackcomp} ; then
	local __hpi=1.5707963268
    else
	local __hpi=1.5707963267948966
    fi
    if [ $__square -eq 0 ] ; then
	ax0t=`gawk -v "factor=$1" -v "beta_x=$2" -v "beta_x2=$3" -v "ratio=$__ratio" -v "kang=$7" -v "hpi=${__hpi}" 'END{print(factor*(sqrt(beta_x)+sqrt(beta_x2*ratio))*cos(hpi*kang))}' /dev/null`
    else
	if [ $__ratio -le "$one" ] ;then
	    ax0t=`gawk -v "factor=$1" -v "beta_x=$2" -v "beta_x2=$3" -v "ratio=$__ratio" 'END{print(factor*(sqrt(beta_x)+sqrt(beta_x2*ratio)))}' /dev/null`
	else
	    ax0t=`gawk -v "factor=$1" -v "beta_y=$4" -v "beta_y2=$5" -v "ratio=$__ratio" -v "kang=$7" -v "hpi=${__hpi}" 'END{print(factor*(sqrt(beta_y2/ratio)+sqrt(beta_y))*cos(hpi*kang)/sin(hpi*kang))}' /dev/null`
	fi
    fi
    ax0=`gawk -v "ax0t=${ax0t}" -v "ns=$9"    'END{ax0=ax0t*ns;print ax0}' /dev/null`
    ax1=`gawk -v "ax0t=${ax0t}" -v "ne=${10}" 'END{ax1=ax0t*ne;print ax1}' /dev/null`
}
sixdeskCreateUserTree(){
    if [ ! -d $sixdeskhomeStudies ] ; then
	mkdir $sixdeskhomeStudies
    fi
}
sixdeskSetExes(){
    # The path to all scripts etc bin,Bin,scripts, exes, dots
    # NB: actually used only for the listed exes
    sixdeskpath=/afs/cern.ch/group/si/slap/bin/sixdesk
    if [ $# -eq 1 ] ; then
	sixdeskpath=$1
    fi
    export sixdeskpath
    # The following SixTrack version is used for the one-turn
    # SixTrack run to get the Beta values and for all LSF tasks (except DA)
    # and the BNL EXE which is the same I hope
    export SIXTRACKEXE=$sixdeskpath/exes/SixTrack_pro
    if test "$BIGNBLZ" != ""
    then
	export SIXTRACKEXE=$sixdeskpath/exes/SixTrack_bignblz_pro
    fi
    export SIXTRACKBNLEXE=$sixdeskpath/exes/SixTrack_bnl_pro
    # Latest DA version from
    export SIXTRACKDAEXE=$sixdeskpath/exes/SixTrack_crlibm_da_lf95v4200
}
sixdeskSetPlatForm(){
    local __platform=$1
    export sixdeskplatform=`echo "$__platform" | tr '[A-Z]' '[a-z]'`
    if [ "$sixdeskplatform" != "boinc" ] && [ "$sixdeskplatform" != "cpss" ] && [ "$sixdeskplatform" != "lsf" ]  && [ "$sixdeskplatform" != "htcondor" ] ; then
	sixdeskmess="unknown platform: ${sixdeskplatform}"
	sixdeskmess
	return 1
    fi
    export sixdeskjobs=$sixdeskwork/$sixdeskplatform"jobs"
    if [ "$BNL" != "" ] ; then
	export sixdeskbnlin="fort.54"
	export bnlfilenames="beambeam-output.dat beambeamlostID.dat SixTwiss.dat checkdist.dat"
	export bnlfortnames="fort.52 fort.53 fort.51 fort.97"
	if [ "$sixdeskplatform" == "boinc" ] ; then
	    export sixdeskbnlout="fort.10"
	elif [ "$sixdeskplatform" == "cpss" ] ; then
	    export sixdeskbnlout=$bnlfortnames
	elif [ "$sixdeskplatform" == "lsf" ] ; then
	    export sixdeskbnlout=$bnlfilenames
	fi
    fi
    return 0
}
sixDeskSetBOINCVars(){
    # The SixTrack executable is now ????.
    export boincdir=/afs/cern.ch/work/b/boinc
    export sixdeskboincdirname=$workspace"_"$LHCDescrip
    sixdeskboincdir=$boincdir/boinc/$sixdeskboincdirname
    if [ -z ${sixdeskboinctest+x} ] ; then
	if [ "$sixdeskboinctest" == "true" ] ; then
	    sixdeskboincdir=$boincdir/boinctest/$sixdeskboincdirname
	fi
    fi
    export sixdeskboincdir
    export sixdeskparts=`expr $sixdeskpairs \* 2`
    if [ $short -eq 1 -o $da -eq 1 ] ; then
	sixdeskturns=$turnss
    elif [ $long -eq 1 ] ; then
	sixdeskturns=$turnsl
    fi
    if [ "$BNL" != "" ] ; then
	sixdeskturns=$bnlturns
    fi
    export sixdeskturns
    sixdeskfpopse=`expr $sixdeskturns \* $sixdeskparts`
    #sixdeskfpopse=`expr $sixdeskfpopse \* 2`
    #sixdeskfpopse=`expr $sixdeskfpopse / 3`
    sixdeskfpopse=`expr $sixdeskfpopse / 2`
    #sixdeskfpopse=`expr $sixdeskfpopse \* 3`
    sixdeskfpopse=$sixdeskfpopse"000000"

    # --------------------------------------------------------------------------
    # from uploadWorkunit

    # An upper bound on the amount of memory required to process the workunit. 
    # The workunit will only be sent to clients with at least this much
    # available RAM. If exceeded the workunit will be aborted.
    # Measured in bytes.
    export memBound=100000000
    
    # An upper bound on the amount of disk space required to process the
    # workunit. The workunit will only be sent to clients with at least this
    # much available disk space. If exceeded the workunit will be aborted.
    # Measured in bytes.
    # diskBound=200,000,000  ~200MB
    export diskBound=200000000
    
    # An upper bound on the time (in seconds) between sending a result to a
    # client and receiving a reply. If the client doesn't respond within this
    # interval, the server 'gives up' on the result and generates a new result,
    # to be assigned to another client. Don't set this too low. 
    # 20 times the "normal" execution time will probably be a good value.
    # about 30 days
    export delayBound=2400000
    
    # The number of redundant calculations. Set to two or more to achieve
    # redudancy.
    export redundancy=2
    
    # The number of copies of the workunit to issue to clients. Must be at
    # least the number of redundant calculations or higher if a loss of results
    # is expected or if the result should to be obtained fast.
    export copies=2
    
    # The number of errors from clients before the workunit is declared to have
    # an error.
    export errors=5
    
    # The total number of clients to issue the workunit to before it is declared
    # to have an error.
    export numIssues=5

    # The total number of returned results without a concensus is found before
    # the workunit is declared to have an error.
    export resultsWithoutConcensus=3

    # Getting the fpops estimate and multiplying it with 10 to get the bound.
    # Multiply by 4 for the moment but watch for complaints!
    # Try 6 for pentium 4
    export fpopsEstimate=`expr $sixdeskfpopse \* 6`
    export fpopsBound=`expr $fpopsEstimate \* 1000`
    
    # --------------------------------------------------------------------------
    # for megaZip
    export megaZipPath=$boincdir/boinc/upload
}
sixdeskSetCPSSVars(){
    # sixdeskprog/uploadProgram Variables
    # sixdeskProgramName, sixdeskFileName, sixdeskTargetFileName
    # sixdeskVersion, sixdeskAuthor, sixdeskDescription
    export sixdeskexec="$sixdeskpath/exes/SixTrack_4411_crlibm_bnl_ifort_icpss.exe"
    export sixdeskOsMin="5.0"
    export sixdeskOsMax="9.9"
    export sixdeskCpuSpeedMin="100"
    export sixdeskclientv=2.5
    export sixdeskProgramName="Sixtrack V4211 Tilt Lost CRLIBM CR BNL"
    export sixdeskFileName="$sixdeskexec"
    export sixdeskTargetFileName="sixtrack.exe"
    export sixdeskVersion="4.2.11 BNL"
    export sixdeskAuthor="Frank Schmidt & Eric McIntosh"
    export sixdeskProgramDescription="Lahey 7.1 Sixtrack[CR] with crlibm made fom .s"
    # sixdeskgroup/createTaskGroup Variables
    # sixdeskTaskGroupName, sixdeskTaskGroupDescription,
    # sixdeskStatus, sixdeskPriority, sixdeskComments
    export sixdeskTaskGroupName=$LOGNAME"_"$workspace"_"$LHCDescrip
    export sixdeskTaskGroupDescription=$workspace"_"$LHCDescrip
    export sixdeskStatus="Active"
    export sixdeskPriority="Normal"
    export sixdeskComments="$LHCDescrip"
}
sixdeskSetOtherVars(){
    # Turn ON/OFF CASTOR........... true or false 
    export sixdeskcastor="true"
    # Not really needed anymore but must be non-zero!
    export sixdeskcr=1 
    export LHCDesName=$LHCDescrip
    export LHCDesHome=$LHCDescrip
}
sixdeskGetFileName(){
    local __fileName
    __fileName=$(basename "$1")
    __fileName="${__fileName%.*}"
    eval "$2=$__fileName"
}
sixdeskCleanExit(){
    local __exitLevel=0
    if [ $# -eq 1 ] ; then
	__exitLevel=$1
    fi
    for tmpDir in ${lockingDirs[@]} ; do
	sixdesklockdir=$tmpDir
	sixdeskunlock
    done
    sixdeskexit $__exitLevel
}
function __inspectPrerequisite(){
    local __test=$1
    local __entry=$2
    local __lerr=0
    
    test $__test ${__entry}
    if [ $? -ne 0 ] ; then
	sixdeskmess="${__entry} NOT there!"
	sixdeskmess
	let __lerr+=1
    else
	sixdeskmess="${__entry} EXISTs!"
	sixdeskmess
    fi
    return $__lerr
}

function sixdeskInspectPrerequisites(){
    local __path=$1
    local __test=$2
    shift 2
    local __entries=$@
    local __lerr=0
    if [ $# -eq 0 ] ; then
	__inspectPrerequisite ${__test} ${__path}
	let __lerr+=$?
    else
	for tmpEntry in ${__entries} ; do
	    __inspectPrerequisite ${__test} ${__path}/${tmpEntry}
	    let __lerr+=$?
	done
    fi
    return $__lerr
}

function sixdeskSanitizeString(){
    # A.Mereghetti, 2016-12-07
    # for the moment, remove empty spaces, tab and newline chars
    local __istring=$1
    local __cleanArg=`echo "${__istring}" | sed -e 's/\ //g' -e 's/\t//g' -e 's/\n//g'`
    eval "$2=${__cleanArg}"
}

function sixdeskInterceptProblem(){
    adminEmails=( "amereghe@cern.ch" )
    emailSubject='intercepting problem with SixDesk'
    varLines=`compgen -v | while read line; do echo $line=${!line}; done`
    for adminEmail in ${adminEmails[@]} ; do
	echo "${varLines}" | mail -s "${emailSubject}" ${adminEmail}
    done
}
